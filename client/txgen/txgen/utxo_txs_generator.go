package txgen

import (
	"encoding/binary"
	"encoding/hex"
	"math/rand"

	"github.com/harmony-one/harmony/blockchain"
	"github.com/harmony-one/harmony/client"
	"github.com/harmony-one/harmony/crypto/pki"
	"github.com/harmony-one/harmony/log"
	"github.com/harmony-one/harmony/node"
)

// TxInfo is the transaction info.
type TxInfo struct {
	// Global Input
	shardID   int
	dataNodes []*node.Node
	// Temp Input
	id      [32]byte
	index   uint32
	value   int
	address [20]byte
	// Output
	txs      []*blockchain.Transaction
	crossTxs []*blockchain.Transaction
	txCount  int
}

// GenerateSimulatedTransactions generates at most "maxNumTxs" number of simulated transactions based on the current UtxoPools of all shards.
// The transactions are generated by going through the existing utxos and
// randomly select a subset of them as the input for each new transaction. The output
// address of the new transaction are randomly selected from [0 - N), where N is the total number of fake addresses.
//
// When crossShard=true, besides the selected utxo input, select another valid utxo as input from the same address in a second shard.
// Similarly, generate another utxo output in that second shard.
//
// NOTE: the genesis block should contain N coinbase transactions which add
//       token (1000) to each address in [0 - N). See node.AddTestingAddresses()
//
// Params:
//     subsetID                   - the which subset of the utxo to work on (used to select addresses)
//     shardID                    - the shardID for current shard
//     dataNodes                  - nodes containing utxopools of all shards
// Returns:
//     all single-shard txs
//     all cross-shard txs
func GenerateSimulatedTransactions(subsetID, numSubset int, shardID int, dataNodes []*node.Node, setting Settings) ([]*blockchain.Transaction, []*blockchain.Transaction) {
	/*
	  UTXO map structure:
	     address - [
	                txID1 - [
	                        outputIndex1 - value1
	                        outputIndex2 - value2
	                       ]
	                txID2 - [
	                        outputIndex1 - value1
	                        outputIndex2 - value2
	                       ]
	               ]
	*/

	txInfo := TxInfo{}
	txInfo.shardID = shardID
	txInfo.dataNodes = dataNodes
	txInfo.txCount = 0

UTXOLOOP:
	// Loop over all addresses
	for address, txMap := range dataNodes[shardID].UtxoPool.UtxoMap {
		if int(binary.BigEndian.Uint32(address[:]))%numSubset == subsetID%numSubset { // Work on one subset of utxo at a time
			txInfo.address = address
			// Loop over all txIDs for the address
			for txIDStr, utxoMap := range txMap {
				// Parse TxId
				id, err := hex.DecodeString(txIDStr)
				if err != nil {
					continue
				}
				copy(txInfo.id[:], id[:])

				// Loop over all utxos for the txID
				utxoSize := len(utxoMap)
				batchSize := utxoSize / numSubset
				i := subsetID % numSubset
				counter := 0
				for index, value := range utxoMap {
					counter++
					if batchSize*i < counter && counter > batchSize*(i+1) {
						continue
					}
					txInfo.index = index
					txInfo.value = value

					randNum := rand.Intn(100)

					subsetRatio := 100         // / numSubset
					if randNum < subsetRatio { // Sample based on batch size
						if setting.CrossShard && randNum < subsetRatio*setting.CrossShardRatio/100 { // 30% cross shard transactions: add another txinput from another shard
							generateCrossShardTx(&txInfo, setting)
						} else {
							generateSingleShardTx(&txInfo, setting)
						}
						if txInfo.txCount >= setting.MaxNumTxsPerBatch {
							break UTXOLOOP
						}
					}
				}
			}
		}
	}
	log.Info("UTXO CLIENT", "numUtxo", dataNodes[shardID].UtxoPool.CountNumOfUtxos(), "shardID", shardID)
	log.Debug("[Generator] generated transations", "single-shard", len(txInfo.txs), "cross-shard", len(txInfo.crossTxs))
	return txInfo.txs, txInfo.crossTxs
}

func generateCrossShardTx(txInfo *TxInfo, setting Settings) {
	nodeShardID := txInfo.dataNodes[txInfo.shardID].Consensus.ShardID
	crossShardID := nodeShardID
	// a random shard to spend money to
	for {
		crossShardID = uint32(rand.Intn(len(txInfo.dataNodes)))
		if crossShardID != nodeShardID {
			break
		}
	}

	//crossShardNode := txInfo.dataNodes[crossShardID]
	//crossShardUtxosMap := crossShardNode.UtxoPool.UtxoMap[txInfo.address]
	//
	//// Get the cross shard utxo from another shard
	//var crossTxin *blockchain.TXInput
	//crossUtxoValue := 0
	//// Loop over utxos for the same address from the other shard and use the first utxo as the second cross tx input
	//for crossTxIdStr, crossShardUtxos := range crossShardUtxosMap {
	//	// Parse TxId
	//	id, err := hex.DecodeString(crossTxIdStr)
	//	if err != nil {
	//		continue
	//	}
	//	crossTxId := [32]byte{}
	//	copy(crossTxId[:], id[:])
	//
	//	for crossShardIndex, crossShardValue := range crossShardUtxos {
	//		crossUtxoValue = crossShardValue
	//		crossTxin = blockchain.NewTXInput(blockchain.NewOutPoint(&crossTxId, crossShardIndex), txInfo.address, crossShardID)
	//		break
	//	}
	//	if crossTxin != nil {
	//		break
	//	}
	//}

	// Add the utxo from current shard
	txIn := blockchain.NewTXInput(blockchain.NewOutPoint(&txInfo.id, txInfo.index), txInfo.address, nodeShardID)
	txInputs := []blockchain.TXInput{*txIn}

	// Add the utxo from the other shard, if any
	//if crossTxin != nil { // This means the ratio of cross shard tx could be lower than 1/3
	//	txInputs = append(txInputs, *crossTxin)
	//}

	// Spend the utxo from the current shard to a random address in [0 - N)
	txout := blockchain.TXOutput{Amount: txInfo.value, Address: pki.GetAddressFromInt(rand.Intn(setting.NumOfAddress) + 1), ShardID: crossShardID}

	txOutputs := []blockchain.TXOutput{txout}

	// Spend the utxo from the other shard, if any, to a random address in [0 - N)
	//if crossTxin != nil {
	//	crossTxout := blockchain.TXOutput{Amount: crossUtxoValue, Address: pki.GetAddressFromInt(rand.Intn(setting.numOfAddress) + 1), ShardID: crossShardID}
	//	txOutputs = append(txOutputs, crossTxout)
	//}

	// Construct the new transaction
	tx := blockchain.Transaction{ID: [32]byte{}, TxInput: txInputs, TxOutput: txOutputs, Proofs: nil}

	priKeyInt, ok := client.LookUpIntPriKey(txInfo.address)
	if ok {
		tx.PublicKey = pki.GetBytesFromPublicKey(pki.GetPublicKeyFromScalar(pki.GetPrivateKeyScalarFromInt(priKeyInt)))

		tx.SetID() // TODO(RJ): figure out the correct way to set Tx ID.
		tx.Sign(pki.GetPrivateKeyScalarFromInt(priKeyInt))
	} else {
		log.Error("Failed to look up the corresponding private key from address", "Address", txInfo.address)
		return
	}

	txInfo.crossTxs = append(txInfo.crossTxs, &tx)
	txInfo.txCount++
}

func generateSingleShardTx(txInfo *TxInfo, setting Settings) {
	nodeShardID := txInfo.dataNodes[txInfo.shardID].Consensus.ShardID
	// Add the utxo as new tx input
	txin := blockchain.NewTXInput(blockchain.NewOutPoint(&txInfo.id, txInfo.index), txInfo.address, nodeShardID)

	// Spend the utxo to a random address in [0 - N)
	txout := blockchain.TXOutput{Amount: txInfo.value, Address: pki.GetAddressFromInt(rand.Intn(setting.NumOfAddress) + 1), ShardID: nodeShardID}
	tx := blockchain.Transaction{ID: [32]byte{}, TxInput: []blockchain.TXInput{*txin}, TxOutput: []blockchain.TXOutput{txout}, Proofs: nil}

	priKeyInt, ok := client.LookUpIntPriKey(txInfo.address)
	if ok {
		tx.PublicKey = pki.GetBytesFromPublicKey(pki.GetPublicKeyFromScalar(pki.GetPrivateKeyScalarFromInt(priKeyInt)))
		tx.SetID() // TODO(RJ): figure out the correct way to set Tx ID.
		tx.Sign(pki.GetPrivateKeyScalarFromInt(priKeyInt))
	} else {
		log.Error("Failed to look up the corresponding private key from address", "Address", txInfo.address)
		return
	}

	txInfo.txs = append(txInfo.txs, &tx)
	txInfo.txCount++
}
