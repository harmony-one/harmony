package vm

import (
	"bytes"
	"math/big"
	"reflect"
	"strings"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/harmony-one/harmony/accounts/abi"
	"github.com/harmony-one/harmony/crypto/bls"
	"github.com/harmony-one/harmony/numeric"
	"github.com/harmony-one/harmony/staking/types"
)

func blsPublicKey(s string) bls.SerializedPublicKey {
	var pubKey bls.SerializedPublicKey
	b := common.FromHex(s)
	copy(pubKey[:], b)
	return pubKey
}

func blsSignature(s string) bls.SerializedSignature {
	var signature bls.SerializedSignature
	b := common.FromHex(s)
	copy(signature[:], b)
	return signature
}

func TestUnpackCreateValidator(t *testing.T) {
	expected := types.CreateValidator{
		ValidatorAddress: common.HexToAddress("0x7EF2e0048f5bAeDe046f6BF797943daF4ED8CB47"),
		Description: types.Description{
			Name:            "name-x",
			Identity:        "Identity-x",
			Website:         "Website-x",
			SecurityContact: "SecurityContact-x",
			Details:         "Details-x",
		},
		CommissionRates: types.CommissionRates{
			Rate:          numeric.NewDecFromBigInt(big.NewInt(1)),
			MaxRate:       numeric.NewDecFromBigInt(big.NewInt(2)),
			MaxChangeRate: numeric.NewDecFromBigInt(big.NewInt(3)),
		},
		MinSelfDelegation:  big.NewInt(4),
		MaxTotalDelegation: big.NewInt(5),
		SlotPubKeys: []bls.SerializedPublicKey{
			blsPublicKey("111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"),
			blsPublicKey("222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222"),
		},
		SlotKeySigs: []bls.SerializedSignature{
			blsSignature("333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333"),
			blsSignature("444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444"),
		},
		Amount: big.NewInt(6),
	}
	const hexdata = `0x250bbca000000000000000000000000000000000000000000000000000000000000000200000000000000000000000007ef2e0048f5baede046f6bf797943daf4ed8cb4700000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000003200000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000000066e616d652d780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a4964656e746974792d78000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009576562736974652d78000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000115365637572697479436f6e746163742d78000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000944657461696c732d7800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000030111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000603333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333330000000000000000000000000000000000000000000000000000000000000060444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444`
	input := common.FromHex(hexdata)
	es := newEvmStake()
	var id methodID
	copy(id[:], input)
	convertor, exist := es.convertors[id]
	if !exist {
		t.Fatal("invalid staking api")
	}
	typ, stkMsg, err := convertor.toGoStakeMsg(input[4:])
	if err != nil {
		t.Fatal(err)
	}
	if typ != types.DirectiveCreateValidator {
		t.Fatal("expected DirectiveCreateValidator")
	}
	createValidator, ok := stkMsg.(types.CreateValidator)
	if !ok {
		t.Fatal("expected type CreateValidator")
	}
	//fmt.Println(createValidator)
	if !reflect.DeepEqual(createValidator, expected) {
		t.Fatal("createValidator not equal to expected")
	}

}

func TestPackDelegations(t *testing.T) {
	const hexdata = `0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000032000000000000000000000000093ff8fe9bf40051e8763c864b15a0e87f2f9646800000000000000000000000000000000000000000000000000000000000000400000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000093ff8fe9bf40051e8763c864b15a0e87f2f9646800000000000000000000000000000000000000000000000000000000000000400000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4000000000000000000000000000000000000000000000000000000000000000b00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000093ff8fe9bf40051e8763c864b15a0e87f2f9646800000000000000000000000000000000000000000000000000000000000000400000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4000000000000000000000000000000000000000000000000000000000000001500000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000093ff8fe9bf40051e8763c864b15a0e87f2f9646800000000000000000000000000000000000000000000000000000000000000400000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4000000000000000000000000000000000000000000000000000000000000001f000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000`
	input := common.FromHex(hexdata)

	var delegation Delegations
	_abi, _ := abi.JSON(strings.NewReader(stakingJsonABI))
	err := _abi.UnpackIntoInterface(&delegation, "getDelegationsByDelegator", input)
	if err != nil {
		t.Fatalf("Unpack error: %v", err)
	}
	es := newEvmStake()
	var id methodID
	copy(id[:], _abi.Methods["getDelegationsByDelegator"].ID)
	convertor, exist := es.convertors[id]
	if !exist {
		t.Fatal("invalid staking api")
	}
	packed, err := convertor.toSol(delegation)
	if err != nil {
		t.Fatal("convertor pack error:", err)
	}
	if !bytes.Equal(input, packed) {
		t.Fatal("delegations packed not equal to expected")
	}

}
